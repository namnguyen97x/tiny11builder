name: Build Tiny11 ISO

on:
  workflow_call:
    inputs:
      build_type:
        description: 'Build type'
        required: false
        default: 'maker'
        type: string
      iso_url:
        description: 'Windows ISO URL (leave empty to use default Windows 11 25H2 ISO)'
        required: false
        type: string
      version_selector:
        description: 'Windows edition to build (default: Auto - selects Pro)'
        required: false
        default: 'Auto'
        type: string
      remove_defender:
        description: 'Remove Windows Defender (default: false)'
        required: false
        default: 'false'
        type: string
      remove_ai:
        description: 'Remove AI/Copilot components (default: true)'
        required: false
        default: 'true'
        type: string
      remove_edge:
        description: 'Remove Microsoft Edge browser (default: true)'
        required: false
        default: 'true'
        type: string
      remove_store:
        description: 'Remove Microsoft Store (default: true)'
        required: false
        default: 'true'
        type: string
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: false
        default: 'maker'
        type: choice
        options:
          - maker
          - core
          - nano
      iso_url:
        description: 'Windows ISO URL (leave empty to use default Windows 11 25H2 ISO)'
        required: false
        type: string
      version_selector:
        description: 'Windows edition to build (default: Auto - selects Pro)'
        required: false
        default: 'Auto'
        type: choice
        options:
          - Auto
          - Pro
          - Home
          - ProWorkstations
      remove_defender:
        description: 'Remove Windows Defender'
        required: false
        default: false
        type: boolean
      remove_ai:
        description: 'Remove AI/Copilot components'
        required: false
        default: true
        type: boolean
      remove_edge:
        description: 'Remove Microsoft Edge browser'
        required: false
        default: true
        type: boolean
      remove_store:
        description: 'Remove Microsoft Store'
        required: false
        default: true
        type: boolean
      remove_drivers:
        description: 'Remove non-essential drivers (NANO ONLY). Format: comma-separated list (e.g., printer,scanner,bluetooth). To keep a driver, remove its name from the list. Default: all drivers'
        required: false
        default: 'printer,scanner,bluetooth,smartcard,tape,rdp'
        type: string
  push:
    branches:
      - main
    paths:
      - '*.ps1'
      - '.github/workflows/*.yml'
  release:
    types: [published]

permissions:
  contents: read
  actions: read

jobs:
  build:
    runs-on: windows-latest
    timeout-minutes: 180
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup PowerShell
        shell: pwsh
        run: |
          $PSVersionTable
          Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
          
      - name: Download and Mount Windows ISO
        shell: pwsh
        env:
          ISO_URL_SECRET: ${{ secrets.ISO_URL }}
          ISO_URL_INPUT: ${{ github.event.inputs.iso_url || inputs.iso_url }}
          DEFAULT_ISO_URL: 'https://software-static.download.prss.microsoft.com/dbazure/888969d5-f34g-4e03-ac9d-1f9786c66749/26200.6584.250915-1905.25h2_ge_release_svc_refresh_CLIENT_CONSUMER_x64FRE_en-us.iso'
        run: |
          $ErrorActionPreference = 'Stop'
          
          # Determine ISO source
          # Priority: Input ISO_URL (if not empty) > Secret ISO_URL > Default URL
          $isoUrl = $null
          
          # Check if ISO_URL_INPUT is provided and not empty
          if ($env:ISO_URL_INPUT -and $env:ISO_URL_INPUT.Trim() -ne '') {
            Write-Host "Using ISO URL from workflow input..."
            $isoUrl = $env:ISO_URL_INPUT.Trim()
          } elseif ($env:ISO_URL_SECRET -and $env:ISO_URL_SECRET.Trim() -ne '') {
            Write-Host "Using ISO URL from repository secret..."
            $isoUrl = $env:ISO_URL_SECRET.Trim()
          } else {
            Write-Host "ISO URL input is empty, using default Windows 11 25H2 ISO URL..."
            $isoUrl = $env:DEFAULT_ISO_URL
          }
          
          $isoFilePath = "$env:RUNNER_TEMP\windows.iso"
          
          Write-Host "Downloading Windows ISO from: $isoUrl"
          Write-Host "This may take a while depending on your connection speed..."
          
          try {
            # Add User-Agent and headers to bypass Cloudflare protection
            $headers = @{
              'User-Agent' = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
              'Accept' = 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
              'Accept-Language' = 'en-US,en;q=0.5'
              'Accept-Encoding' = 'gzip, deflate, br'
              'Connection' = 'keep-alive'
              'Upgrade-Insecure-Requests' = '1'
              'Referer' = 'https://massgrave.dev/'
            }
            
            $maxRetries = 3
            $retryDelay = 5
            $downloadSuccess = $false
            
            # Retry logic for Cloudflare protection
            for ($retry = 1; $retry -le $maxRetries; $retry++) {
              try {
                Write-Host "Download attempt $retry of $maxRetries..."
                
                # Try downloading with headers
                Invoke-WebRequest -Uri $isoUrl -OutFile $isoFilePath -Headers $headers -UseBasicParsing -TimeoutSec 3600 -MaximumRetryCount 0
                
                # Verify file was downloaded (not Cloudflare HTML page)
                if (Test-Path $isoFilePath) {
                  $fileSize = (Get-Item $isoFilePath).Length
                  # Check if file is too small (likely Cloudflare HTML page)
                  if ($fileSize -lt 1000000) { # Less than 1MB
                    $content = Get-Content $isoFilePath -Raw -ErrorAction SilentlyContinue
                    if ($content -match 'Cloudflare|challenge|blocked') {
                      throw "Downloaded file appears to be Cloudflare challenge page"
                    }
                  }
                  
                  $downloadSuccess = $true
                  Write-Host "✓ ISO downloaded successfully" -ForegroundColor Green
                  break
                }
              } catch {
                if ($retry -lt $maxRetries) {
                  Write-Warning "Download attempt $retry failed: $($_.Exception.Message)"
                  Write-Host "Waiting $retryDelay seconds before retry..."
                  Start-Sleep -Seconds $retryDelay
                  $retryDelay *= 2 # Exponential backoff
                  Remove-Item $isoFilePath -ErrorAction SilentlyContinue
                } else {
                  throw
                }
              }
            }
            
            if (-not $downloadSuccess) {
              throw "Failed to download ISO after $maxRetries attempts"
            }
          } catch {
            Write-Error "Failed to download ISO: $_"
            Write-Warning "If you're getting Cloudflare blocked error, try:"
            Write-Warning "1. Use a direct download URL without Cloudflare protection"
            Write-Warning "2. Or download ISO manually and mount it, then use local path"
            Write-Warning "3. Or use GitHub Actions secret ISO_URL with a direct download link"
            exit 1
          }
          
          # Verify ISO file exists
          if (-not (Test-Path $isoFilePath)) {
            Write-Error "ISO file not found at: $isoFilePath"
            exit 1
          }
          
          $isoSize = (Get-Item $isoFilePath).Length / 1GB
          Write-Host "Downloaded ISO size: $([math]::Round($isoSize, 2)) GB"
          
          Write-Host "Mounting ISO file: $isoFilePath"
          
          # Mount ISO and get drive letter
          try {
            $mountResult = Mount-DiskImage -ImagePath $isoFilePath -PassThru -ErrorAction Stop
            $volume = $mountResult | Get-Volume
            $isoDriveLetter = $volume.DriveLetter
            
            if ($isoDriveLetter) {
              $isoDrive = "$isoDriveLetter`:"
              Write-Host "✓ ISO mounted successfully to drive: $isoDrive" -ForegroundColor Green
              echo "ISO_DRIVE=$isoDrive" >> $env:GITHUB_ENV
              echo "ISO_FILE_PATH=$isoFilePath" >> $env:GITHUB_ENV
            } else {
              Write-Error "Failed to get drive letter from mounted ISO"
              exit 1
            }
          } catch {
            Write-Error "Failed to mount ISO: $_"
            exit 1
          }
          
      - name: Build Tiny11 ISO
        shell: pwsh
        env:
          BUILD_TYPE: ${{ github.event.inputs.build_type || inputs.build_type || 'maker' }}
          VERSION_SELECTOR: ${{ github.event.inputs.version_selector || inputs.version_selector || 'Auto' }}
          REMOVE_DEFENDER: ${{ github.event.inputs.remove_defender || inputs.remove_defender || 'false' }}
          REMOVE_AI: ${{ github.event.inputs.remove_ai || inputs.remove_ai || 'true' }}
          REMOVE_EDGE: ${{ github.event.inputs.remove_edge || inputs.remove_edge || 'true' }}
          REMOVE_STORE: ${{ github.event.inputs.remove_store || inputs.remove_store || 'true' }}
          REMOVE_DRIVERS: ${{ github.event.inputs.remove_drivers || inputs.remove_drivers || 'printer,scanner,bluetooth,smartcard,tape,rdp' }}
        run: |
          # Set error handling - continue on non-critical errors
          $ErrorActionPreference = 'Continue'
          $script:buildFailed = $false
          $script:buildError = $null
          
          # Get ISO drive from mounted ISO
          $isoDrive = $env:ISO_DRIVE
          if (-not $isoDrive) {
            Write-Error "ISO drive not set. Mount step may have failed."
            exit 1
          }
          
          # Scratch drive will use runner temp or current directory
          $scratchDrive = $PSScriptRoot
          
          Write-Host "Building Tiny11 ISO..."
          Write-Host "ISO Drive: $isoDrive"
          Write-Host "Scratch Drive: $scratchDrive"
          Write-Host "Build Type: $env:BUILD_TYPE"
          
          # Build arguments - use hashtable for named parameters
          $buildParams = @{}
          
          # Extract drive letter (remove colon)
          if ($isoDrive -match '^([A-Z]):$') {
            $buildParams['ISO'] = $Matches[1]
          } else {
            Write-Error "Invalid ISO drive format: $isoDrive"
            exit 1
          }
          
          # Determine script to run
          $buildType = $env:BUILD_TYPE
          $scriptName = switch ($buildType) {
            'core' { 'tiny11Coremaker.ps1' }
            'nano' { 'nano11maker.ps1' }
            default { 'tiny11maker.ps1' }
          }
          
          # Add NonInteractive flag for CI/CD
          $buildParams['NonInteractive'] = $true
          
          # Add version selector
          $versionSelector = if ($env:VERSION_SELECTOR) { $env:VERSION_SELECTOR } else { 'Auto' }
          $buildParams['VersionSelector'] = $versionSelector
          Write-Host "Version selector: $versionSelector"
          
          # Helper function to convert boolean/string to yes/no
          function Convert-ToYesNo {
            param($value, $default = 'yes')
            if (-not $value) { return $default }
            $str = $value.ToString().ToLower()
            if ($str -eq 'true' -or $str -eq '1' -or $str -eq 'yes') { return 'yes' }
            return 'no'
          }
          
          # Add optional debloat parameters for all build types (maker, core, nano)
          # All build types now honor workflow debloat settings
          Write-Host "Adding optional debloat parameters..."
          
          $buildParams['RemoveDefender'] = Convert-ToYesNo $env:REMOVE_DEFENDER 'no'
          $buildParams['RemoveAI'] = Convert-ToYesNo $env:REMOVE_AI 'yes'
          $buildParams['RemoveEdge'] = Convert-ToYesNo $env:REMOVE_EDGE 'yes'
          $buildParams['RemoveStore'] = Convert-ToYesNo $env:REMOVE_STORE 'yes'
          
          # Add driver removal parameters (NANO ONLY)
          # These parameters are only passed to nano11maker.ps1, not to tiny11maker.ps1 or tiny11Coremaker.ps1
          if ($buildType -eq 'nano') {
            # Parse driver removal string (format: "printer,scanner,bluetooth,smartcard,tape,rdp" or "all" or empty)
            # If a driver name is NOT in the list, it will NOT be removed (will be kept)
            $driverRemoveStr = if ($env:REMOVE_DRIVERS) { $env:REMOVE_DRIVERS.Trim().ToLower() } else { 'all' }
            
            # If "all" or empty, remove all drivers by default
            if ($driverRemoveStr -eq 'all' -or $driverRemoveStr -eq '') {
              $driverRemoveStr = 'printer,scanner,bluetooth,smartcard,tape,rdp'
            }
            
            # Parse individual driver types from comma-separated list
            $driverList = $driverRemoveStr -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
            
            # Set each driver removal parameter based on whether it's in the list
            # If driver name is IN the list → 'yes' (remove it)
            # If driver name is NOT in the list → 'no' (keep it)
            $buildParams['RemovePrinterDrivers'] = if ($driverList -contains 'printer') { 'yes' } else { 'no' }
            $buildParams['RemoveScannerDrivers'] = if ($driverList -contains 'scanner') { 'yes' } else { 'no' }
            $buildParams['RemoveBluetoothDrivers'] = if ($driverList -contains 'bluetooth') { 'yes' } else { 'no' }
            $buildParams['RemoveSmartcardDrivers'] = if ($driverList -contains 'smartcard') { 'yes' } else { 'no' }
            $buildParams['RemoveTapeDrivers'] = if ($driverList -contains 'tape') { 'yes' } else { 'no' }
            $buildParams['RemoveRdpDrivers'] = if ($driverList -contains 'rdp') { 'yes' } else { 'no' }
            
            Write-Host "Driver removal options (nano): Printer=$($buildParams['RemovePrinterDrivers']), Scanner=$($buildParams['RemoveScannerDrivers']), Bluetooth=$($buildParams['RemoveBluetoothDrivers']), Smartcard=$($buildParams['RemoveSmartcardDrivers']), Tape=$($buildParams['RemoveTapeDrivers']), RDP=$($buildParams['RemoveRdpDrivers'])"
            Write-Host "Driver removal input: $driverRemoveStr"
            Write-Host "Note: Drivers NOT in the list will be KEPT (not removed)"
          }
          
          Write-Host "Debloat options ($buildType): Defender=$($buildParams['RemoveDefender']), AI=$($buildParams['RemoveAI']), Edge=$($buildParams['RemoveEdge']), Store=$($buildParams['RemoveStore'])"
          
          Write-Host "Running: $scriptName"
          Write-Host "Parameters: ISO=$($buildParams['ISO']), NonInteractive=$($buildParams['NonInteractive']), VersionSelector=$($buildParams['VersionSelector'])"
          Write-Host "  Debloat: Defender=$($buildParams['RemoveDefender']), AI=$($buildParams['RemoveAI']), Edge=$($buildParams['RemoveEdge']), Store=$($buildParams['RemoveStore'])"
          if ($buildType -eq 'nano') {
            Write-Host "  Drivers: Printer=$($buildParams['RemovePrinterDrivers']), Scanner=$($buildParams['RemoveScannerDrivers']), Bluetooth=$($buildParams['RemoveBluetoothDrivers']), Smartcard=$($buildParams['RemoveSmartcardDrivers']), Tape=$($buildParams['RemoveTapeDrivers']), RDP=$($buildParams['RemoveRdpDrivers'])"
          }
          
          # Run the builder script with splatting
          # Catch errors but continue - scripts have their own error handling
          try {
            & ".\$scriptName" @buildParams 2>&1 | ForEach-Object {
              if ($_ -match "Removal failed|Warning.*Failed to remove") {
                Write-Warning $_
              } else {
                Write-Host $_
              }
            }
            
            # Check exit code
            if ($LASTEXITCODE -ne 0) {
              Write-Warning "Script exited with code $LASTEXITCODE, but continuing to check for ISO..."
            }
          } catch {
            Write-Warning "Error running script: $($_.Exception.Message)"
            $script:buildFailed = $true
            $script:buildError = $_
          }
          
          # Check if ISO was created (different names for different build types)
          $isoName = switch ($buildType) {
            'core' { 'tiny11-core.iso' }
            'nano' { 'nano11.iso' }
            default { 'tiny11.iso' }
          }
          # Use repository workspace, not $PSScriptRoot (which points to a temp script path in GitHub Actions)
          $repoRoot = $env:GITHUB_WORKSPACE
          $isoPath = Join-Path $repoRoot $isoName
          
          if (Test-Path $isoPath) {
            Write-Host "\u2713 ISO created successfully: $isoPath" -ForegroundColor Green
            $isoSize = (Get-Item $isoPath).Length / 1GB
            Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
            # Exit successfully even if there were warnings
            exit 0
          } else {
            Write-Error "ISO was not created at expected path: $isoPath"
            if ($script:buildError) {
              Write-Error "Build error: $($script:buildError.Exception.Message)"
            }
            exit 1
          }
          
      - name: Upload ISO artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: ${{ github.event.inputs.build_type || inputs.build_type || 'maker' }}-iso-${{ github.run_number }}
          path: |
            tiny11.iso
            tiny11-core.iso
            nano11.iso
            *.log
          retention-days: 7
          compression-level: 0
          
      - name: Create Release
        if: github.event_name == 'release' && github.event.action == 'published'
        shell: pwsh
        run: |
          $isoPath = "tiny11.iso"
          if (Test-Path $isoPath) {
            Write-Host "Preparing release asset..."
            $isoSize = (Get-Item $isoPath).Length / 1GB
            Write-Host "ISO size: $([math]::Round($isoSize, 2)) GB"
            
            # Note: Actual release upload would be handled by release action
            # This step just prepares the file
          }
          
      - name: Cleanup
        if: always()
        shell: pwsh
        env:
          ISO_FILE_PATH: ${{ env.ISO_FILE_PATH }}
        run: |
          # Unmount ISO if we mounted it
          if ($env:ISO_FILE_PATH) {
            Write-Host "Unmounting ISO: $env:ISO_FILE_PATH"
            try {
              Get-DiskImage | Where-Object { $_.ImagePath -eq $env:ISO_FILE_PATH } | Dismount-DiskImage -ErrorAction Stop
              Write-Host "\u2713 ISO unmounted successfully" -ForegroundColor Green
            } catch {
              Write-Warning "Failed to unmount ISO: $_"
            }
            
            # Cleanup temporary ISO file if it was downloaded
            if ($env:ISO_FILE_PATH -like "*RUNNER_TEMP*") {
              Write-Host "Removing temporary ISO file..."
              Remove-Item -Path $env:ISO_FILE_PATH -Force -ErrorAction SilentlyContinue
            }
          }
